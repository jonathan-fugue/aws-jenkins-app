export
    type opaque App
    app

    type AppCluster
    new

import Fugue.AWS
import Fugue.AWS.AutoScaling
import Fugue.AWS.EC2
import Fugue.AWS.ECS
import Fugue.AWS.ELB
import Fugue.AWS.IAM
import Fugue.Random as Random


# An app is basically a docker image together with some parameters.  You can
# deploy multiple apps in an `AppCluster`.  For every app, the appropriate
# resources (including a separate load balancer, security group...) will be
# created.
type App:
  | App {
      name: String,
      image: String,
      port: Int,
      memory: Int,
      managedPolicies: List<Fugue.AWS.IAM.ManagedPolicy>,
      volumes: List<Fugue.AWS.ECS.Volume>,
      logGroupName: Optional<String>,
    }

# Constructor to create a new `App`.
#
# @arg name Descriptive name for the application.  Lowercase and hyphen is
# recommended.
#
# @arg image Name of the docker image.
#
# @arg port Port on which your docker image listens.  Defaults to 8000.
#
# @arg memory Amount of memory available to the image, in MB.  Defaults to 256.
#
# @arg managedPolicies Extra policies your docker image needs (e.g. SQS access).
# TODO: The use should be able to specify inline policies as well.
#
# @arg logGroupName CloudWatch log group name to send logs to.
fun app {
  name: String,
  image: String,
  logGroupName: Optional<String>,
  port: Optional<Int>,
  memory: Optional<Int>,
  managedPolicies: Optional<List<Fugue.AWS.IAM.ManagedPolicy>>,
  volumes: Optional<List<Fugue.AWS.ECS.Volume>>
} -> App:
  App {
    name: name,
    image: image,
    port: port ?| 8000,
    memory: memory ?| 256,
    logGroupName: logGroupName,
    managedPolicies: managedPolicies ?| [],
    volumes: volumes ?| []
  }

type AppCluster:
  | AppCluster {
      cluster: Fugue.AWS.ECS.Cluster,
      services: List<Fugue.AWS.ECS.Service>,
      asg: Fugue.AWS.AutoScaling.AutoScalingGroup
    }

# Create a new `AppCluster`
#
# @arg name Name of the cluster.  Using lowercase and hyphens is recommended.
#
# @arg network Network to deploy the cluster in.
#
# @arg size Number of instances in the network.  Defaults to the number apps +
# 1.
fun new {
  name: String,
  subnets: List<Fugue.AWS.EC2.Subnet>,
  vpc: Optional<Fugue.AWS.EC2.Vpc>,
  region: Optional<Fugue.AWS.Region>,
  apps: List<App>,
  size: Optional<Int>,
  keyName: Optional<String>,
  tags: Optional<List<Fugue.AWS.Tag>>
} -> AppCluster:
  let _vpc: vpc ?| List.index(subnets,0).(Fugue.AWS.EC2.Subnet).vpc
  let _region: region ?| _vpc.(Fugue.AWS.EC2.Vpc).region
  let _size: size ?| List.length(apps) + 1
  let _tags: tags ?| []
  let _random: Random.randomString{length: 8}

  # Security group for the cluster instances
  let sg: Fugue.AWS.EC2.SecurityGroup.new {
    vpc: _vpc,
    description: "ECS Cluster Container Instances " ++ _random,
    ipPermissions: List.concat(
      [
        Fugue.AWS.EC2.IpPermission.http(
          Fugue.AWS.EC2.IpPermission.Target.all
        )
      ],
      [
        Fugue.AWS.EC2.IpPermission.tcp(
          app.App.port,
          Fugue.AWS.EC2.IpPermission.Target.all
        ) for app in apps
      ]
    ),
    tags: _tags
  }

  # Cluster to hold the containers
  let clusterName: name ++ "-cluster-" ++ _random
  let cluster: Fugue.AWS.ECS.Cluster.new {
    name: clusterName,
    region: _region
  }

  # Role for the clusters
  let clusterInstanceRole: Fugue.AWS.IAM.Role.new {
    roleName: name ++ "-instance-role-" ++ _random,
    assumeRolePolicyDocument: Fugue.AWS.IAM.Policy.AssumeRole.ec2,
    managedPolicies: [ 
      Fugue.AWS.IAM.ManagedPolicy.external(
        "arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role"
      )
    ]
  }

  # Launch configuration for instances in the cluster.
  let lc: Fugue.AWS.AutoScaling.LaunchConfiguration.new {
    image: lookupEcsOptimizedImage(_region),
    securityGroups: [sg],
    instanceType: Fugue.AWS.EC2.T2_large,
    keyName: keyName,
    iamInstanceProfile: Fugue.AWS.IAM.InstanceProfile.new {
      instanceProfileName: name ++ "-profile-" ++ _random,
      roles: [clusterInstanceRole]
    },
    userData: Template.render {
      data: {cluster: clusterName},
      template:
        '#!/bin/bash
        \echo ECS_CLUSTER={{cluster}} >> /etc/ecs/ecs.config
        \'
    }
  }

  # Autoscaling group containing the actual instances in the cluster.
  let asg: Fugue.AWS.AutoScaling.AutoScalingGroup.new {
    name: name ++ "-asg-" ++ _random,
    launchConfiguration: lc,
    subnets: subnets,
    loadBalancers: [],
    minSize: _size,
    maxSize: _size,
    defaultCooldown: 300,
    healthCheckType: Fugue.AWS.AutoScaling.Ec2,
    enabledMetrics: [
      Fugue.AWS.AutoScaling.GroupInServiceInstances,
      Fugue.AWS.AutoScaling.GroupTotalInstances
    ],
    tags: List.concat([Fugue.AWS.tag("Name", name ++ "-asg-" ++ _random)], _tags)
  }

  # Now, we create a service for every app in our list.
  let services: [
    createServiceForApp {
      subnets: subnets,
      vpc: vpc,
      region: region,
      cluster: cluster,
      tags: _tags,
      app: app
    } for app in apps
  ]

  AppCluster {
    cluster: cluster,
    services: services,
    asg: asg
  }

# Helper function: creating a service for an 'App' specification.
fun createServiceForApp {
  subnets: List<Fugue.AWS.EC2.Subnet>,
  vpc: Optional<Fugue.AWS.EC2.Vpc>,
  region: Optional<Fugue.AWS.Region>,
  cluster: Fugue.AWS.ECS.Cluster,
  tags: List<Fugue.AWS.Tag>,
  app: App
} -> Fugue.AWS.ECS.Service:
  let _vpc: Optional.unpack(List.index(subnets,0).(Fugue.AWS.EC2.Subnet).vpc, vpc)
  let _region: Optional.unpack(_vpc.(Fugue.AWS.EC2.Vpc).region, region)
  let _random: Random.randomString{length: 8}

  # Security group for the cluster instances
  let sg: Fugue.AWS.EC2.SecurityGroup.new {
    vpc: _vpc,
    description: "ECS Cluster Container Instances " ++ _random,
    ipPermissions: [
      Fugue.AWS.EC2.IpPermission.http(
        Fugue.AWS.EC2.IpPermission.Target.all
      ),
      Fugue.AWS.EC2.IpPermission.tcp(
        app.App.port,
        Fugue.AWS.EC2.IpPermission.Target.all
      )
    ],
    tags: tags
  }

  # Load balancer for the app.
  let elb: Fugue.AWS.ELB.LoadBalancer.new {
    loadBalancerName: app.App.name ++ "-" ++ _random ++ "-elb",
    subnets: subnets,
    healthCheck: Fugue.AWS.ELB.HealthCheck.tcp {
      port: app.App.port,
      interval: 10,
      timeout: 5,
      unhealthyThreshold: 6,
      healthyThreshold: 3,
    },
    securityGroups: [sg],
    scheme: Fugue.AWS.ELB.InternetFacing,
    crossZone: True,
    listeners: [
      Fugue.AWS.ELB.Listener.new {
        protocol: Fugue.AWS.ELB.HTTP,
        loadBalancerPort: 80,
        instanceProtocol: Fugue.AWS.ELB.HTTP,
        instancePort: app.App.port,
      },
    ],
    tags: tags
  }

  # Container definition for the instances running the webapp
  let containerName: app.App.name ++ "-" ++ _random ++ "-container"
  let containerDefinition: Fugue.AWS.ECS.ContainerDefinition.new {
    name: containerName,
    image: app.App.image,
    memory: app.App.memory,
    portMappings: [
      Fugue.AWS.ECS.PortMapping.tcp {
        containerPort: app.App.port,
        hostPort: app.App.port
      }
    ],
  }

  # The awslogs smart constructor is currently not exported so we need to use
  # the core type here.
  # Single element dictionary
  let options0: { "awslogs-region": Fugue.AWS.Region.toString(_region) }
  let options:
    case app.App.logGroupName of
      # if app.App.logGroupName is None, just use options0
      | None -> options0
      # if app.App.logGroupName is not None, insert it into Dictionary
      | Optional logGroupName ->
          Dictionary.insert("awslogs-group", logGroupName, options0)
  let __logConfiguration: Fugue.AWS.ECS.LogConfiguration {
    logDriver: Fugue.AWS.ECS.Awslogs,
    options: options
  }

  # Role for the task.
  let taskRole: Fugue.AWS.IAM.Role.new {
    roleName: app.App.name ++ "-" ++ _random ++ "-task-role",
    assumeRolePolicyDocument: '{
      \  "Version": "2008-10-17",
      \  "Statement": [
      \    {
      \      "Sid": "",
      \      "Effect": "Allow",
      \      "Principal": {
      \        "Service": "ecs-tasks.amazonaws.com"
      \      },
      \      "Action": "sts:AssumeRole"
      \    }
      \  ]
      \}',
    managedPolicies: app.App.managedPolicies,
    rolePolicies: []
  }

  # Task running the containers
  let task: Fugue.AWS.ECS.TaskDefinition.new {
    family: app.App.name ++ "-" ++ _random ++ "-task",
    containerDefinitions: [containerDefinition],
    volumes: app.App.volumes,
    role: taskRole,
    region: _region
  }

  # Role for the service.
  let serviceRole: Fugue.AWS.IAM.Role.new {
    roleName: app.App.name ++ "-" ++ _random ++ "-service-role",
    assumeRolePolicyDocument: '{
      \  "Version": "2008-10-17",
      \  "Statement": [
      \    {
      \      "Sid": "",
      \      "Effect": "Allow",
      \      "Principal": {
      \        "Service": "ecs.amazonaws.com"
      \      },
      \      "Action": "sts:AssumeRole"
      \    }
      \  ]
      \}',
    managedPolicies: [
      Fugue.AWS.IAM.ManagedPolicy.external(
        "arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceRole"
      ),
    ],
    rolePolicies: [
      Fugue.AWS.IAM.Policy.new {
        policyName: app.App.name ++ "-" ++ _random ++ "-describe-instance-health",
        policyDocument: '{
          \  "Version": "2012-10-17",
          \  "Statement": [
          \    {
          \      "Effect": "Allow",
          \      "Action": "elasticloadbalancing:DescribeInstanceHealth",
          \      "Resource": "*"
          \    }
          \  ]
          \}'
      }
    ]
  }

  Fugue.AWS.ECS.Service.new {
    name: app.App.name ++ "-" ++ _random ++ "-service",
    cluster: cluster,
    taskDefinition: task,
    numDesired: 1,
    role: serviceRole,
    loadBalancer: Fugue.AWS.ECS.LoadBalancer.classicLoadBalancer {
      containerName: containerName,
      containerPort: app.App.port,
      loadBalancer: elb
    },
    deploymentConfiguration: Fugue.AWS.ECS.DeploymentConfiguration {
      minimumHealthyPercent: 50,
      maximumPercent: 100
    }
  }

# Find the ECS-optimized image for a specific region.  Throws an error if there
# is no such image.
#
# See also: <http://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html>.
fun lookupEcsOptimizedImage(region: Fugue.AWS.Region) -> String:
  case region of
    | Fugue.AWS.Region.Us-east-2       -> "ami-34032e51"
    | Fugue.AWS.Region.Us-east-1       -> "ami-ec33cc96"
    | Fugue.AWS.Region.Us-west-2       -> "ami-29f80351"
    | Fugue.AWS.Region.Us-west-1       -> "ami-d5d0e0b5"
    | Fugue.AWS.Region.Eu-west-2       -> "ami-eb62708f"
    | Fugue.AWS.Region.Eu-west-1       -> "ami-13f7226a"
    | Fugue.AWS.Region.Eu-central-1    -> "ami-40d5672f"
    | Fugue.AWS.Region.Ap-northeast-2  -> "ami-7ee13b10"
    | Fugue.AWS.Region.Ap-northeast-1  -> "ami-21815747"
    | Fugue.AWS.Region.Ap-southeast-2  -> "ami-4f08e82d"
    | Fugue.AWS.Region.Ap-southeast-1  -> "ami-99f588fa"
    | Fugue.AWS.Region.Ca-central-1    -> "ami-9b54edff"
    | _                                -> error(
        "No ECS-optimized image for " ++ Fugue.AWS.Region.toString(region)
      )
